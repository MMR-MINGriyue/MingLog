/**
 * 增强的跨模块链接服务
 * 实现深度的跨模块数据关联和链接管理
 */

import { EventEmitter } from 'events'
import { DataAssociationService, EntityType, AssociationType, AssociationRecord } from './DataAssociationService'
import { CrossModuleEventBus, EventType } from './CrossModuleEventBus'
import { UnifiedSearchService, UnifiedSearchResult } from './UnifiedSearchService'

// 链接类型定义
export enum LinkType {
  REFERENCE = 'reference',           // 引用链接
  EMBED = 'embed',                   // 嵌入链接
  BIDIRECTIONAL = 'bidirectional',   // 双向链接
  HIERARCHY = 'hierarchy',           // 层级链接
  DEPENDENCY = 'dependency',         // 依赖链接
  SIMILARITY = 'similarity',         // 相似性链接
  TEMPORAL = 'temporal',             // 时间关联链接
  SEMANTIC = 'semantic'              // 语义链接
}

// 链接强度等级
export enum LinkStrength {
  WEAK = 0.3,
  MEDIUM = 0.6,
  STRONG = 0.9
}

// 跨模块实体接口
export interface CrossModuleEntity {
  id: string
  type: EntityType
  moduleId: string
  title: string
  content?: string
  metadata?: Record<string, any>
  createdAt: Date
  updatedAt: Date
}

// 增强的链接记录
export interface EnhancedLinkRecord extends AssociationRecord {
  linkType: LinkType
  context?: string                   // 链接上下文
  anchor?: string                    // 锚点文本
  position?: number                  // 在源文档中的位置
  isAutoGenerated: boolean           // 是否自动生成
  confidence: number                 // 链接置信度
  lastVerified: Date                 // 最后验证时间
  tags: string[]                     // 链接标签
}

// 链接建议
export interface LinkSuggestion {
  id: string
  sourceEntity: CrossModuleEntity
  targetEntity: CrossModuleEntity
  linkType: LinkType
  confidence: number
  reason: string                     // 建议原因
  context?: string
  autoApply: boolean                 // 是否可自动应用
}

// 链接图谱节点
export interface LinkGraphNode {
  id: string
  entity: CrossModuleEntity
  links: EnhancedLinkRecord[]
  position?: { x: number; y: number }
  cluster?: string                   // 所属集群
  importance: number                 // 重要性评分
}

// 链接图谱
export interface LinkGraph {
  nodes: LinkGraphNode[]
  edges: EnhancedLinkRecord[]
  clusters: { [key: string]: LinkGraphNode[] }
  metadata: {
    totalNodes: number
    totalEdges: number
    density: number                  // 图密度
    avgDegree: number               // 平均度数
  }
}

/**
 * 增强的跨模块链接服务
 */
export class EnhancedCrossModuleLinkService extends EventEmitter {
  private links: Map<string, EnhancedLinkRecord> = new Map()
  private entities: Map<string, CrossModuleEntity> = new Map()
  private linkIndex: Map<string, Set<string>> = new Map() // 实体ID -> 链接ID集合
  private suggestionCache: Map<string, LinkSuggestion[]> = new Map()
  private autoLinkEnabled: boolean = true

  constructor(
    private dataAssociationService: DataAssociationService,
    private eventBus: CrossModuleEventBus,
    private searchService: UnifiedSearchService
  ) {
    super()
    this.setupEventListeners()
  }

  /**
   * 设置事件监听器
   */
  private setupEventListeners(): void {
    // 监听实体变更事件
    this.eventBus.on(EventType.NOTE_CREATED, this.handleEntityCreated.bind(this))
    this.eventBus.on(EventType.NOTE_UPDATED, this.handleEntityUpdated.bind(this))
    this.eventBus.on(EventType.TASK_CREATED, this.handleEntityCreated.bind(this))
    this.eventBus.on(EventType.TASK_UPDATED, this.handleEntityUpdated.bind(this))
    this.eventBus.on(EventType.MINDMAP_NODE_ADDED, this.handleEntityCreated.bind(this))
    this.eventBus.on(EventType.MINDMAP_NODE_UPDATED, this.handleEntityUpdated.bind(this))
  }

  /**
   * 注册跨模块实体
   */
  async registerEntity(entity: CrossModuleEntity): Promise<void> {
    this.entities.set(entity.id, entity)
    
    // 初始化链接索引
    if (!this.linkIndex.has(entity.id)) {
      this.linkIndex.set(entity.id, new Set())
    }

    // 如果启用自动链接，生成链接建议
    if (this.autoLinkEnabled) {
      await this.generateLinkSuggestions(entity)
    }

    // 发送事件
    this.emit('entity:registered', entity)
  }

  /**
   * 创建增强链接
   */
  async createEnhancedLink(
    sourceId: string,
    targetId: string,
    linkType: LinkType,
    options: {
      context?: string
      anchor?: string
      position?: number
      tags?: string[]
      strength?: LinkStrength
    } = {}
  ): Promise<EnhancedLinkRecord> {
    const sourceEntity = this.entities.get(sourceId)
    const targetEntity = this.entities.get(targetId)

    if (!sourceEntity || !targetEntity) {
      throw new Error('Source or target entity not found')
    }

    const linkRecord: EnhancedLinkRecord = {
      id: this.generateLinkId(),
      sourceType: sourceEntity.type,
      sourceId: sourceEntity.id,
      targetType: targetEntity.type,
      targetId: targetEntity.id,
      associationType: this.mapLinkTypeToAssociation(linkType),
      linkType,
      strength: options.strength || LinkStrength.MEDIUM,
      context: options.context,
      anchor: options.anchor,
      position: options.position,
      isAutoGenerated: false,
      confidence: 1.0,
      lastVerified: new Date(),
      tags: options.tags || [],
      metadata: {},
      createdAt: new Date(),
      updatedAt: new Date()
    }

    // 保存链接
    this.links.set(linkRecord.id, linkRecord)
    
    // 更新索引
    this.linkIndex.get(sourceId)?.add(linkRecord.id)
    this.linkIndex.get(targetId)?.add(linkRecord.id)

    // 如果是双向链接，创建反向链接
    if (linkType === LinkType.BIDIRECTIONAL) {
      await this.createReverseLink(linkRecord)
    }

    // 发送事件
    this.emit('link:created', linkRecord)
    this.eventBus.publishEvent(EventType.ASSOCIATION_CREATED, 'cross-module-link', {
      link: linkRecord
    })

    return linkRecord
  }

  /**
   * 生成链接建议
   */
  async generateLinkSuggestions(entity: CrossModuleEntity): Promise<LinkSuggestion[]> {
    const cacheKey = `${entity.id}:${entity.updatedAt.getTime()}`
    
    // 检查缓存
    if (this.suggestionCache.has(cacheKey)) {
      return this.suggestionCache.get(cacheKey)!
    }

    const suggestions: LinkSuggestion[] = []

    // 1. 基于内容相似性的建议
    const contentSuggestions = await this.generateContentBasedSuggestions(entity)
    suggestions.push(...contentSuggestions)

    // 2. 基于标签的建议
    const tagSuggestions = await this.generateTagBasedSuggestions(entity)
    suggestions.push(...tagSuggestions)

    // 3. 基于时间关联的建议
    const temporalSuggestions = await this.generateTemporalSuggestions(entity)
    suggestions.push(...temporalSuggestions)

    // 4. 基于用户行为的建议
    const behaviorSuggestions = await this.generateBehaviorBasedSuggestions(entity)
    suggestions.push(...behaviorSuggestions)

    // 排序和去重
    const uniqueSuggestions = this.deduplicateSuggestions(suggestions)
    const sortedSuggestions = uniqueSuggestions
      .sort((a, b) => b.confidence - a.confidence)
      .slice(0, 10) // 限制建议数量

    // 缓存结果
    this.suggestionCache.set(cacheKey, sortedSuggestions)

    return sortedSuggestions
  }

  /**
   * 构建链接图谱
   */
  async buildLinkGraph(
    centerEntityId: string,
    depth: number = 2,
    options: {
      includeTypes?: EntityType[]
      excludeTypes?: EntityType[]
      minStrength?: number
      maxNodes?: number
    } = {}
  ): Promise<LinkGraph> {
    const visited = new Set<string>()
    const nodes: LinkGraphNode[] = []
    const edges: EnhancedLinkRecord[] = []

    // 广度优先遍历构建图谱
    await this.buildGraphRecursive(centerEntityId, depth, visited, nodes, edges, options)

    // 计算图谱统计信息
    const metadata = this.calculateGraphMetadata(nodes, edges)

    // 聚类分析
    const clusters = this.performClustering(nodes, edges)

    return {
      nodes,
      edges,
      clusters,
      metadata
    }
  }

  /**
   * 智能链接推荐
   */
  async getSmartLinkRecommendations(
    entityId: string,
    context?: string
  ): Promise<LinkSuggestion[]> {
    const entity = this.entities.get(entityId)
    if (!entity) return []

    // 生成多种类型的建议
    const suggestions = await this.generateLinkSuggestions(entity)

    // 基于上下文过滤和重新排序
    if (context) {
      return this.filterSuggestionsByContext(suggestions, context)
    }

    return suggestions
  }

  /**
   * 自动应用高置信度链接
   */
  async autoApplyHighConfidenceLinks(entityId: string): Promise<EnhancedLinkRecord[]> {
    const suggestions = await this.getSmartLinkRecommendations(entityId)
    const appliedLinks: EnhancedLinkRecord[] = []

    for (const suggestion of suggestions) {
      if (suggestion.autoApply && suggestion.confidence > 0.8) {
        try {
          const link = await this.createEnhancedLink(
            suggestion.sourceEntity.id,
            suggestion.targetEntity.id,
            suggestion.linkType,
            {
              context: suggestion.context,
              tags: ['auto-generated']
            }
          )
          
          link.isAutoGenerated = true
          link.confidence = suggestion.confidence
          appliedLinks.push(link)
        } catch (error) {
          console.error('Failed to auto-apply link:', error instanceof Error ? error.message : String(error))
        }
      }
    }

    return appliedLinks
  }

  // 私有辅助方法
  private async handleEntityCreated(event: any): Promise<void> {
    // 处理实体创建事件
    if (event.data && event.data.entity) {
      await this.registerEntity(event.data.entity)
    }
  }

  private async handleEntityUpdated(event: any): Promise<void> {
    // 处理实体更新事件
    if (event.data && event.data.entity) {
      const entity = event.data.entity
      this.entities.set(entity.id, entity)
      
      // 清除相关缓存
      this.clearSuggestionCache(entity.id)
      
      // 重新生成建议
      if (this.autoLinkEnabled) {
        await this.generateLinkSuggestions(entity)
      }
    }
  }

  private mapLinkTypeToAssociation(linkType: LinkType): AssociationType {
    const mapping = {
      [LinkType.REFERENCE]: AssociationType.REFERENCE,
      [LinkType.EMBED]: AssociationType.REFERENCE,
      [LinkType.BIDIRECTIONAL]: AssociationType.REFERENCE,
      [LinkType.HIERARCHY]: AssociationType.HIERARCHY,
      [LinkType.DEPENDENCY]: AssociationType.DEPENDENCY,
      [LinkType.SIMILARITY]: AssociationType.SIMILARITY,
      [LinkType.TEMPORAL]: AssociationType.TEMPORAL,
      [LinkType.SEMANTIC]: AssociationType.SEMANTIC
    }
    return mapping[linkType] || AssociationType.REFERENCE
  }

  private async createReverseLink(originalLink: EnhancedLinkRecord): Promise<void> {
    // 创建反向链接的逻辑
    const reverseLink: EnhancedLinkRecord = {
      ...originalLink,
      id: this.generateLinkId(),
      sourceType: originalLink.targetType,
      sourceId: originalLink.targetId,
      targetType: originalLink.sourceType,
      targetId: originalLink.sourceId
    }

    this.links.set(reverseLink.id, reverseLink)
    this.linkIndex.get(reverseLink.sourceId)?.add(reverseLink.id)
    this.linkIndex.get(reverseLink.targetId)?.add(reverseLink.id)
  }

  private async generateContentBasedSuggestions(entity: CrossModuleEntity): Promise<LinkSuggestion[]> {
    // 基于内容相似性生成建议
    if (!entity.content) return []

    const searchResults = await this.searchService.semanticSearch(entity.content, {
      limit: 20,
      entityTypes: [EntityType.NOTE, EntityType.TASK, EntityType.MINDMAP_NODE]
    })

    return searchResults
      .filter(result => result.id !== entity.id)
      .map(result => ({
        id: this.generateSuggestionId(),
        sourceEntity: entity,
        targetEntity: this.resultToEntity(result),
        linkType: LinkType.SIMILARITY,
        confidence: result.score,
        reason: '内容相似性',
        autoApply: result.score > 0.8
      }))
  }

  private async generateTagBasedSuggestions(entity: CrossModuleEntity): Promise<LinkSuggestion[]> {
    // 基于标签生成建议
    const tags = entity.metadata?.tags || []
    if (tags.length === 0) return []

    // 实现标签匹配逻辑
    return []
  }

  private async generateTemporalSuggestions(entity: CrossModuleEntity): Promise<LinkSuggestion[]> {
    // 基于时间关联生成建议
    return []
  }

  private async generateBehaviorBasedSuggestions(entity: CrossModuleEntity): Promise<LinkSuggestion[]> {
    // 基于用户行为生成建议
    return []
  }

  private deduplicateSuggestions(suggestions: LinkSuggestion[]): LinkSuggestion[] {
    const seen = new Set<string>()
    return suggestions.filter(suggestion => {
      const key = `${suggestion.sourceEntity.id}-${suggestion.targetEntity.id}-${suggestion.linkType}`
      if (seen.has(key)) return false
      seen.add(key)
      return true
    })
  }

  private async buildGraphRecursive(
    entityId: string,
    depth: number,
    visited: Set<string>,
    nodes: LinkGraphNode[],
    edges: EnhancedLinkRecord[],
    options: any
  ): Promise<void> {
    // 递归构建图谱的实现
  }

  private calculateGraphMetadata(nodes: LinkGraphNode[], edges: EnhancedLinkRecord[]): any {
    return {
      totalNodes: nodes.length,
      totalEdges: edges.length,
      density: edges.length / (nodes.length * (nodes.length - 1) / 2),
      avgDegree: (edges.length * 2) / nodes.length
    }
  }

  private performClustering(nodes: LinkGraphNode[], edges: EnhancedLinkRecord[]): { [key: string]: LinkGraphNode[] } {
    // 聚类分析实现
    return {}
  }

  private filterSuggestionsByContext(suggestions: LinkSuggestion[], context: string): LinkSuggestion[] {
    // 基于上下文过滤建议
    return suggestions
  }

  private clearSuggestionCache(entityId: string): void {
    // 清除相关的建议缓存
    for (const [key] of this.suggestionCache) {
      if (key.startsWith(entityId)) {
        this.suggestionCache.delete(key)
      }
    }
  }

  private resultToEntity(result: UnifiedSearchResult): CrossModuleEntity {
    return {
      id: result.id,
      type: result.type,
      moduleId: result.moduleId || 'unknown',
      title: result.title,
      content: result.content,
      metadata: result.metadata,
      createdAt: new Date(result.createdAt || Date.now()),
      updatedAt: new Date(result.updatedAt || Date.now())
    }
  }

  private generateLinkId(): string {
    return `link_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`
  }

  private generateSuggestionId(): string {
    return `suggestion_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`
  }
}

export default EnhancedCrossModuleLinkService
