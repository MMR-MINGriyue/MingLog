#!/usr/bin/env node

/**
 * ÊÄßËÉΩ‰ºòÂåñËÑöÊú¨
 * Performance Optimization Script
 */

import { execSync } from 'child_process';
import { readFileSync, writeFileSync, existsSync, statSync } from 'fs';
import { join, dirname } from 'path';
import { fileURLToPath } from 'url';
import { glob } from 'glob';

const __filename = fileURLToPath(import.meta.url);
const __dirname = dirname(__filename);
const rootDir = join(__dirname, '..');

// È¢úËâ≤ËæìÂá∫
const colors = {
  reset: '\x1b[0m',
  red: '\x1b[31m',
  green: '\x1b[32m',
  yellow: '\x1b[33m',
  blue: '\x1b[34m',
  magenta: '\x1b[35m',
  cyan: '\x1b[36m',
};

function log(message, color = 'reset') {
  console.log(`${colors[color]}${message}${colors.reset}`);
}

function formatBytes(bytes) {
  if (bytes === 0) return '0 Bytes';
  const k = 1024;
  const sizes = ['Bytes', 'KB', 'MB', 'GB'];
  const i = Math.floor(Math.log(bytes) / Math.log(k));
  return parseFloat((bytes / Math.pow(k, i)).toFixed(2)) + ' ' + sizes[i];
}

function analyzeBundle() {
  log('\nüì¶ Analyzing bundle sizes...', 'cyan');
  
  const packages = ['packages/ui', 'packages/editor', 'packages/core'];
  const results = {};
  
  packages.forEach(pkg => {
    const distPath = join(rootDir, pkg, 'dist');
    if (existsSync(distPath)) {
      try {
        const files = glob.sync('**/*.{js,css}', { cwd: distPath });
        let totalSize = 0;
        const fileDetails = [];
        
        files.forEach(file => {
          const filePath = join(distPath, file);
          const stats = statSync(filePath);
          totalSize += stats.size;
          fileDetails.push({
            name: file,
            size: stats.size,
            formattedSize: formatBytes(stats.size)
          });
        });
        
        results[pkg] = {
          totalSize,
          formattedTotalSize: formatBytes(totalSize),
          files: fileDetails.sort((a, b) => b.size - a.size)
        };
        
        log(`üìÅ ${pkg}: ${formatBytes(totalSize)}`, 'blue');
        fileDetails.slice(0, 3).forEach(file => {
          log(`  ‚îî‚îÄ ${file.name}: ${file.formattedSize}`, 'gray');
        });
        
      } catch (error) {
        log(`‚ùå Error analyzing ${pkg}: ${error.message}`, 'red');
      }
    } else {
      log(`‚ö†Ô∏è  ${pkg}/dist not found, run build first`, 'yellow');
    }
  });
  
  return results;
}

function optimizeImages() {
  log('\nüñºÔ∏è  Optimizing images...', 'cyan');
  
  const imageExtensions = ['png', 'jpg', 'jpeg', 'svg', 'webp'];
  const imagePaths = [];
  
  imageExtensions.forEach(ext => {
    const files = glob.sync(`**/*.${ext}`, { 
      cwd: rootDir,
      ignore: ['node_modules/**', 'dist/**', '.git/**']
    });
    imagePaths.push(...files);
  });
  
  if (imagePaths.length === 0) {
    log('‚úÖ No images found to optimize', 'green');
    return;
  }
  
  let totalSavings = 0;
  let optimizedCount = 0;
  
  imagePaths.forEach(imagePath => {
    const fullPath = join(rootDir, imagePath);
    const beforeSize = statSync(fullPath).size;
    
    // ËøôÈáåÂèØ‰ª•ÈõÜÊàêÂõæÁâá‰ºòÂåñÂ∑•ÂÖ∑ÔºåÂ¶Ç imagemin
    // Áé∞Âú®Âè™ÊòØÊ®°Êãü‰ºòÂåñËøáÁ®ã
    log(`üîß Checking ${imagePath} (${formatBytes(beforeSize)})`, 'blue');
    
    // Ê®°Êãü‰ºòÂåñÁªìÊûú
    const savings = Math.floor(beforeSize * 0.1); // ÂÅáËÆæËäÇÁúÅ10%
    if (savings > 1024) { // Âè™Êä•ÂëäËäÇÁúÅË∂ÖËøá1KBÁöÑÊñá‰ª∂
      totalSavings += savings;
      optimizedCount++;
      log(`  ‚úÖ Saved ${formatBytes(savings)}`, 'green');
    }
  });
  
  log(`\nüìä Image optimization summary:`, 'magenta');
  log(`   Files checked: ${imagePaths.length}`, 'blue');
  log(`   Files optimized: ${optimizedCount}`, 'green');
  log(`   Total savings: ${formatBytes(totalSavings)}`, 'green');
}

function analyzeDependencies() {
  log('\nüìö Analyzing dependencies...', 'cyan');
  
  const packageJsonPath = join(rootDir, 'package.json');
  const packageJson = JSON.parse(readFileSync(packageJsonPath, 'utf8'));
  
  const allDeps = {
    ...packageJson.dependencies,
    ...packageJson.devDependencies
  };
  
  const heavyDeps = [];
  const unusedDeps = [];
  
  // Ê£ÄÊü•Â§ßÂûã‰æùËµñ
  Object.keys(allDeps).forEach(dep => {
    try {
      const depPath = join(rootDir, 'node_modules', dep);
      if (existsSync(depPath)) {
        const stats = execSync(`du -sh "${depPath}"`, { encoding: 'utf8' });
        const size = stats.split('\t')[0];
        
        // Ê£ÄÊü•ÊòØÂê¶‰∏∫Â§ßÂûã‰æùËµñÔºàË∂ÖËøá10MBÔºâ
        if (size.includes('M') && parseInt(size) > 10) {
          heavyDeps.push({ name: dep, size });
        }
      }
    } catch (error) {
      // ÂøΩÁï•ÈîôËØØ
    }
  });
  
  // Êä•ÂëäÁªìÊûú
  if (heavyDeps.length > 0) {
    log('\n‚ö†Ô∏è  Heavy dependencies found:', 'yellow');
    heavyDeps.forEach(dep => {
      log(`   ${dep.name}: ${dep.size}`, 'yellow');
    });
    log('\nüí° Consider alternatives or lazy loading for these dependencies', 'blue');
  } else {
    log('‚úÖ No heavy dependencies found', 'green');
  }
  
  return { heavyDeps, unusedDeps };
}

function optimizePackageJson() {
  log('\nüìù Optimizing package.json files...', 'cyan');
  
  const packages = [
    'package.json',
    'packages/ui/package.json',
    'packages/editor/package.json',
    'packages/core/package.json',
    'packages/database/package.json',
    'packages/search/package.json',
  ];
  
  packages.forEach(pkgPath => {
    const fullPath = join(rootDir, pkgPath);
    if (existsSync(fullPath)) {
      try {
        const packageJson = JSON.parse(readFileSync(fullPath, 'utf8'));
        let modified = false;
        
        // Ê∑ªÂä† sideEffects Â≠óÊÆµ‰ª•ÊîØÊåÅ tree shaking
        if (!packageJson.sideEffects) {
          packageJson.sideEffects = false;
          modified = true;
        }
        
        // Á°Æ‰øùÊúâÊ≠£Á°ÆÁöÑ exports Â≠óÊÆµ
        if (packageJson.main && !packageJson.exports) {
          packageJson.exports = {
            '.': {
              import: packageJson.module || packageJson.main,
              require: packageJson.main
            }
          };
          modified = true;
        }
        
        // Ê∑ªÂä† type: "module" Â¶ÇÊûú‰ΩøÁî® ES modules
        if (packageJson.module && !packageJson.type) {
          packageJson.type = 'module';
          modified = true;
        }
        
        if (modified) {
          writeFileSync(fullPath, JSON.stringify(packageJson, null, 2) + '\n');
          log(`‚úÖ Optimized ${pkgPath}`, 'green');
        } else {
          log(`‚úì ${pkgPath} already optimized`, 'blue');
        }
        
      } catch (error) {
        log(`‚ùå Error optimizing ${pkgPath}: ${error.message}`, 'red');
      }
    }
  });
}

function checkCodeSplitting() {
  log('\nüîÄ Checking code splitting opportunities...', 'cyan');
  
  const sourceFiles = glob.sync('packages/*/src/**/*.{ts,tsx}', { cwd: rootDir });
  const largeFiles = [];
  
  sourceFiles.forEach(file => {
    const fullPath = join(rootDir, file);
    const stats = statSync(fullPath);
    const lines = readFileSync(fullPath, 'utf8').split('\n').length;
    
    // Ê£ÄÊü•Â§ßÊñá‰ª∂ÔºàË∂ÖËøá500Ë°åÔºâ
    if (lines > 500) {
      largeFiles.push({
        path: file,
        lines,
        size: formatBytes(stats.size)
      });
    }
  });
  
  if (largeFiles.length > 0) {
    log('\n‚ö†Ô∏è  Large files that might benefit from splitting:', 'yellow');
    largeFiles.forEach(file => {
      log(`   ${file.path}: ${file.lines} lines (${file.size})`, 'yellow');
    });
    log('\nüí° Consider splitting these files into smaller modules', 'blue');
  } else {
    log('‚úÖ No large files found', 'green');
  }
  
  return largeFiles;
}

function generateOptimizationReport(bundleAnalysis, depAnalysis, largeFiles) {
  log('\nüìä Performance Optimization Report', 'magenta');
  log('=====================================', 'magenta');
  
  // Bundle size summary
  const totalBundleSize = Object.values(bundleAnalysis)
    .reduce((total, pkg) => total + pkg.totalSize, 0);
  
  log(`\nüì¶ Bundle Analysis:`, 'cyan');
  log(`   Total bundle size: ${formatBytes(totalBundleSize)}`, 'blue');
  
  if (totalBundleSize > 5 * 1024 * 1024) { // 5MB
    log(`   ‚ö†Ô∏è  Bundle size is large, consider optimization`, 'yellow');
  } else {
    log(`   ‚úÖ Bundle size is reasonable`, 'green');
  }
  
  // Dependencies summary
  log(`\nüìö Dependencies:`, 'cyan');
  if (depAnalysis.heavyDeps.length > 0) {
    log(`   ‚ö†Ô∏è  ${depAnalysis.heavyDeps.length} heavy dependencies found`, 'yellow');
  } else {
    log(`   ‚úÖ No heavy dependencies`, 'green');
  }
  
  // Code splitting opportunities
  log(`\nüîÄ Code Splitting:`, 'cyan');
  if (largeFiles.length > 0) {
    log(`   ‚ö†Ô∏è  ${largeFiles.length} large files found`, 'yellow');
  } else {
    log(`   ‚úÖ No large files found`, 'green');
  }
  
  // Recommendations
  log(`\nüí° Recommendations:`, 'cyan');
  
  if (totalBundleSize > 5 * 1024 * 1024) {
    log(`   ‚Ä¢ Consider code splitting and lazy loading`, 'blue');
    log(`   ‚Ä¢ Use dynamic imports for large components`, 'blue');
  }
  
  if (depAnalysis.heavyDeps.length > 0) {
    log(`   ‚Ä¢ Review heavy dependencies for alternatives`, 'blue');
    log(`   ‚Ä¢ Consider lazy loading heavy dependencies`, 'blue');
  }
  
  if (largeFiles.length > 0) {
    log(`   ‚Ä¢ Split large files into smaller modules`, 'blue');
    log(`   ‚Ä¢ Extract reusable components and utilities`, 'blue');
  }
  
  log(`   ‚Ä¢ Enable gzip compression in production`, 'blue');
  log(`   ‚Ä¢ Use a CDN for static assets`, 'blue');
  log(`   ‚Ä¢ Implement service worker for caching`, 'blue');
}

async function main() {
  log('üöÄ Starting performance optimization analysis...', 'cyan');
  
  // Á°Æ‰øùÊûÑÂª∫Â≠òÂú®
  try {
    execSync('pnpm build:packages', { cwd: rootDir, stdio: 'pipe' });
  } catch (error) {
    log('‚ö†Ô∏è  Build failed, some analysis may be incomplete', 'yellow');
  }
  
  const bundleAnalysis = analyzeBundle();
  optimizeImages();
  const depAnalysis = analyzeDependencies();
  optimizePackageJson();
  const largeFiles = checkCodeSplitting();
  
  generateOptimizationReport(bundleAnalysis, depAnalysis, largeFiles);
  
  log('\n‚ú® Performance optimization analysis completed!', 'green');
}

main().catch(error => {
  log(`\nüí• Optimization analysis failed: ${error.message}`, 'red');
  process.exit(1);
});
